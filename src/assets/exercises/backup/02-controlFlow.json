{
  "id": "02-controlFlow",
  "title": "Control Flow",
  "exercises": [
    {
      "name": "createPersonWithHobbies",
      "description": "Create a person object with name, age, city, and an array of hobbies",
      "jsTemplate": "function createPersonWithHobbies(name, age, city, hobbies) {\n  // TODO: Create and return a person object with name, age, city properties\n  // and a hobbies array\n  \n}",
      "pyTemplate": "def createPersonWithHobbies(name, age, city, hobbies):\n    # TODO: Create and return a person dictionary with name, age, city keys\n    # and a hobbies list\n    pass",
      "jsTest": "    it(\"should create a person object with correct properties including hobbies array\", () => {\n      const hobbies = [\"reading\", \"hiking\", \"coding\"];\n      const person = createPersonWithHobbies(\"Alice\", 25, \"New York\", hobbies);\n      assert.strictEqual(person.name, \"Alice\");\n      assert.strictEqual(person.age, 25);\n      assert.strictEqual(person.city, \"New York\");\n      assert.deepStrictEqual(person.hobbies, hobbies);\n    });",
      "pyTest": "    def test_create_person_with_hobbies(self):\n        hobbies = [\"reading\", \"hiking\", \"coding\"]\n        person = createPersonWithHobbies(\"Alice\", 25, \"New York\", hobbies)\n        self.assertEqual(person[\"name\"], \"Alice\")\n        self.assertEqual(person[\"age\"], 25)\n        self.assertEqual(person[\"city\"], \"New York\")\n        self.assertEqual(person[\"hobbies\"], hobbies)"
    },
    {
      "name": "convertTypes",
      "description": "Convert different types of data based on specified operations",
      "jsTemplate": "function convertTypes(stringNum, numberValue, booleanValue) {\n  // TODO: Return an object with the following properties:\n  // - stringAsNumber: Convert stringNum to a number\n  // - numberAsString: Convert numberValue to a string\n  // - booleanAsString: Convert booleanValue to a string\n  // - numberAsBoolean: Convert numberValue to a boolean\n  \n}",
      "pyTemplate": "def convertTypes(string_num, number_value, boolean_value):\n    # TODO: Return a dictionary with the following keys:\n    # - string_as_number: Convert string_num to a number\n    # - number_as_string: Convert number_value to a string\n    # - boolean_as_string: Convert boolean_value to a string\n    # - number_as_boolean: Convert number_value to a boolean\n    pass",
      "jsTest": "    it(\"should correctly convert between different types\", () => {\n      const result = convertTypes(\"42\", 7, true);\n      assert.strictEqual(result.stringAsNumber, 42);\n      assert.strictEqual(result.numberAsString, \"7\");\n      assert.strictEqual(result.booleanAsString, \"true\");\n      assert.strictEqual(result.numberAsBoolean, true);\n      \n      const result2 = convertTypes(\"0\", 0, false);\n      assert.strictEqual(result2.stringAsNumber, 0);\n      assert.strictEqual(result2.numberAsString, \"0\");\n      assert.strictEqual(result2.booleanAsString, \"false\");\n      assert.strictEqual(result2.numberAsBoolean, false);\n    });",
      "pyTest": "    def test_convert_types(self):\n        result = convertTypes(\"42\", 7, True)\n        self.assertEqual(result[\"string_as_number\"], 42)\n        self.assertEqual(result[\"number_as_string\"], \"7\")\n        self.assertEqual(result[\"boolean_as_string\"], \"True\")\n        self.assertEqual(result[\"number_as_boolean\"], True)\n        \n        result2 = convertTypes(\"0\", 0, False)\n        self.assertEqual(result2[\"string_as_number\"], 0)\n        self.assertEqual(result2[\"number_as_string\"], \"0\")\n        self.assertEqual(result2[\"boolean_as_string\"], \"False\")\n        self.assertEqual(result2[\"number_as_boolean\"], False)"
    },
    {
      "name": "updateAddress",
      "description": "Update an address object without modifying the original object",
      "jsTemplate": "function updateAddress(addressObj, streetUpdate, cityUpdate) {\n  // TODO: Return a new address object with updated street and city\n  // without modifying the original addressObj\n  // Tip: Don't use direct assignment - create a new object\n  \n}",
      "pyTemplate": "def updateAddress(address_dict, street_update, city_update):\n    # TODO: Return a new address dictionary with updated street and city\n    # without modifying the original address_dict\n    # Tip: Don't use direct assignment - create a new dictionary\n    pass",
      "jsTest": "    it(\"should update address without modifying original object\", () => {\n      const originalAddress = {\n        street: \"123 Main St\",\n        city: \"Boston\",\n        zip: \"02108\"\n      };\n      const originalCopy = {...originalAddress};\n      \n      const updatedAddress = updateAddress(originalAddress, \"456 Park Ave\", \"New York\");\n      \n      // Check that original wasn't modified\n      assert.deepStrictEqual(originalAddress, originalCopy);\n      \n      // Check that new object has correct values\n      assert.strictEqual(updatedAddress.street, \"456 Park Ave\");\n      assert.strictEqual(updatedAddress.city, \"New York\");\n      assert.strictEqual(updatedAddress.zip, \"02108\");\n    });",
      "pyTest": "    def test_update_address(self):\n        original_address = {\n            \"street\": \"123 Main St\",\n            \"city\": \"Boston\",\n            \"zip\": \"02108\"\n        }\n        import copy\n        original_copy = copy.deepcopy(original_address)\n        \n        updated_address = updateAddress(original_address, \"456 Park Ave\", \"New York\")\n        \n        # Check that original wasn't modified\n        self.assertEqual(original_address, original_copy)\n        \n        # Check that new dictionary has correct values\n        self.assertEqual(updated_address[\"street\"], \"456 Park Ave\")\n        self.assertEqual(updated_address[\"city\"], \"New York\")\n        self.assertEqual(updated_address[\"zip\"], \"02108\")"
    },
    {
      "name": "formatFullName",
      "description": "Format a full name from first, middle, and last name variables",
      "jsTemplate": "function formatFullName(firstName, lastName, middleName = \"\") {\n  // TODO: Return a formatted full name based on the following rules:\n  // - If middleName is provided, return \"firstName middleName lastName\"\n  // - If no middleName is provided, return \"firstName lastName\"\n  // - All parts of the name should have the first letter capitalized,\n  //   regardless of how they were passed in\n  \n}",
      "pyTemplate": "def formatFullName(first_name, last_name, middle_name = \"\"):\n    # TODO: Return a formatted full name based on the following rules:\n    # - If middle_name is provided, return \"first_name middle_name last_name\"\n    # - If no middle_name is provided, return \"first_name last_name\"\n    # - All parts of the name should have the first letter capitalized,\n    #   regardless of how they were passed in\n    pass",
      "jsTest": "    it(\"should format full name correctly with proper capitalization\", () => {\n      assert.strictEqual(formatFullName(\"john\", \"doe\"), \"John Doe\");\n      assert.strictEqual(formatFullName(\"jane\", \"smith\", \"marie\"), \"Jane Marie Smith\");\n      assert.strictEqual(formatFullName(\"ROBERT\", \"JONES\"), \"Robert Jones\");\n      assert.strictEqual(formatFullName(\"sara\", \"WILLIAMS\", \"ann\"), \"Sara Ann Williams\");\n    });",
      "pyTest": "    def test_format_full_name(self):\n        self.assertEqual(formatFullName(\"john\", \"doe\"), \"John Doe\")\n        self.assertEqual(formatFullName(\"jane\", \"smith\", \"marie\"), \"Jane Marie Smith\")\n        self.assertEqual(formatFullName(\"ROBERT\", \"JONES\"), \"Robert Jones\")\n        self.assertEqual(formatFullName(\"sara\", \"WILLIAMS\", \"ann\"), \"Sara Ann Williams\")"
    },
    {
      "name": "calculateRectangleProperties",
      "description": "Calculate area and perimeter of a rectangle",
      "jsTemplate": "function calculateRectangleProperties(length, width) {\n  // TODO: Return an object with:\n  // - area: the area of the rectangle (length × width)\n  // - perimeter: the perimeter of the rectangle (2 × (length + width))\n  // - isSquare: boolean indicating if the rectangle is a square (length === width)\n  \n}",
      "pyTemplate": "def calculateRectangleProperties(length, width):\n    # TODO: Return a dictionary with:\n    # - area: the area of the rectangle (length × width)\n    # - perimeter: the perimeter of the rectangle (2 × (length + width))\n    # - is_square: boolean indicating if the rectangle is a square (length == width)\n    pass",
      "jsTest": "    it(\"should calculate rectangle properties correctly\", () => {\n      const square = calculateRectangleProperties(5, 5);\n      assert.strictEqual(square.area, 25);\n      assert.strictEqual(square.perimeter, 20);\n      assert.strictEqual(square.isSquare, true);\n      \n      const rectangle = calculateRectangleProperties(4, 6);\n      assert.strictEqual(rectangle.area, 24);\n      assert.strictEqual(rectangle.perimeter, 20);\n      assert.strictEqual(rectangle.isSquare, false);\n    });",
      "pyTest": "    def test_calculate_rectangle_properties(self):\n        square = calculateRectangleProperties(5, 5)\n        self.assertEqual(square[\"area\"], 25)\n        self.assertEqual(square[\"perimeter\"], 20)\n        self.assertEqual(square[\"is_square\"], True)\n        \n        rectangle = calculateRectangleProperties(4, 6)\n        self.assertEqual(rectangle[\"area\"], 24)\n        self.assertEqual(rectangle[\"perimeter\"], 20)\n        self.assertEqual(rectangle[\"is_square\"], False)"
    },
    {
      "name": "filterAndTransform",
      "description": "Filter and transform an array of numbers",
      "jsTemplate": "function filterAndTransform(numbers) {\n  // TODO: Create and return a new array from the input array\n  // that filters out negative numbers and doubles the positive ones\n  // Example: [1, -2, 3, -4, 5] → [2, 6, 10]\n  \n}",
      "pyTemplate": "def filterAndTransform(numbers):\n    # TODO: Create and return a new list from the input list\n    # that filters out negative numbers and doubles the positive ones\n    # Example: [1, -2, 3, -4, 5] → [2, 6, 10]\n    pass",
      "jsTest": "    it(\"should filter out negative numbers and double the positive ones\", () => {\n      assert.deepStrictEqual(filterAndTransform([1, -2, 3, -4, 5]), [2, 6, 10]);\n      assert.deepStrictEqual(filterAndTransform([-1, -2, -3]), []);\n      assert.deepStrictEqual(filterAndTransform([10, 20, 30]), [20, 40, 60]);\n      assert.deepStrictEqual(filterAndTransform([]), []);\n    });",
      "pyTest": "    def test_filter_and_transform(self):\n        self.assertEqual(filterAndTransform([1, -2, 3, -4, 5]), [2, 6, 10])\n        self.assertEqual(filterAndTransform([-1, -2, -3]), [])\n        self.assertEqual(filterAndTransform([10, 20, 30]), [20, 40, 60])\n        self.assertEqual(filterAndTransform([]), [])"
    },
    {
      "name": "createCounter",
      "description": "Create a counter object with methods to manipulate the count",
      "jsTemplate": "function createCounter(initialValue = 0) {\n  // TODO: Return an object with the following methods:\n  // - getValue(): returns the current count\n  // - increment(): increases count by 1 and returns the new value\n  // - decrement(): decreases count by 1 and returns the new value\n  // - reset(): resets count to initialValue and returns the new value\n  \n}",
      "pyTemplate": "def createCounter(initial_value = 0):\n    # TODO: Return a dictionary with the following functions:\n    # - get_value: returns the current count\n    # - increment: increases count by 1 and returns the new value\n    # - decrement: decreases count by 1 and returns the new value\n    # - reset: resets count to initial_value and returns the new value\n    pass",
      "jsTest": "    it(\"should create a working counter object with correct methods\", () => {\n      const counter = createCounter(5);\n      assert.strictEqual(counter.getValue(), 5);\n      assert.strictEqual(counter.increment(), 6);\n      assert.strictEqual(counter.increment(), 7);\n      assert.strictEqual(counter.decrement(), 6);\n      assert.strictEqual(counter.reset(), 5);\n      \n      const defaultCounter = createCounter();\n      assert.strictEqual(defaultCounter.getValue(), 0);\n      assert.strictEqual(defaultCounter.decrement(), -1);\n    });",
      "pyTest": "    def test_create_counter(self):\n        counter = createCounter(5)\n        self.assertEqual(counter[\"get_value\"](), 5)\n        self.assertEqual(counter[\"increment\"](), 6)\n        self.assertEqual(counter[\"increment\"](), 7)\n        self.assertEqual(counter[\"decrement\"](), 6)\n        self.assertEqual(counter[\"reset\"](), 5)\n        \n        default_counter = createCounter()\n        self.assertEqual(default_counter[\"get_value\"](), 0)\n        self.assertEqual(default_counter[\"decrement\"](), -1)"
    },
    {
      "name": "mergeAndFilter",
      "description": "Merge two objects and filter properties based on a test function",
      "jsTemplate": "function mergeAndFilter(obj1, obj2, testFn) {\n  // TODO: Create a new object that merges properties from obj1 and obj2\n  // Include only properties where testFn(value) returns true\n  // If both objects have the same property, obj2's value takes precedence\n  \n}",
      "pyTemplate": "def mergeAndFilter(obj1, obj2, test_fn):\n    # TODO: Create a new dictionary that merges properties from obj1 and obj2\n    # Include only properties where test_fn(value) returns True\n    # If both dictionaries have the same key, obj2's value takes precedence\n    pass",
      "jsTest": "    it(\"should merge objects and filter properties based on test function\", () => {\n      const obj1 = { a: 1, b: -2, c: 3 };\n      const obj2 = { b: 2, d: 4, e: -5 };\n      \n      // Test function that keeps only positive numbers\n      const keepPositive = (value) => value > 0;\n      \n      const result = mergeAndFilter(obj1, obj2, keepPositive);\n      \n      // Should have a, b, c, d but not e (as it's negative)\n      assert.deepStrictEqual(result, { a: 1, b: 2, c: 3, d: 4 });\n      \n      // Test with a different filter (keep even numbers)\n      const keepEven = (value) => value % 2 === 0;\n      const result2 = mergeAndFilter(obj1, obj2, keepEven);\n      assert.deepStrictEqual(result2, { b: 2, d: 4 });\n    });",
      "pyTest": "    def test_merge_and_filter(self):\n        obj1 = { \"a\": 1, \"b\": -2, \"c\": 3 }\n        obj2 = { \"b\": 2, \"d\": 4, \"e\": -5 }\n        \n        # Test function that keeps only positive numbers\n        def keep_positive(value):\n            return value > 0\n        \n        result = mergeAndFilter(obj1, obj2, keep_positive)\n        \n        # Should have a, b, c, d but not e (as it's negative)\n        self.assertEqual(result, { \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4 })\n        \n        # Test with a different filter (keep even numbers)\n        def keep_even(value):\n            return value % 2 == 0\n            \n        result2 = mergeAndFilter(obj1, obj2, keep_even)\n        self.assertEqual(result2, { \"b\": 2, \"d\": 4 })"
    }
  ],
  "resources": {
    "javascript": [
      "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Variables",
      "https://javascript.info/variables",
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects",
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"
    ],
    "python": [
      "https://docs.python.org/3/tutorial/introduction.html#numbers",
      "https://realpython.com/python-variables/",
      "https://docs.python.org/3/tutorial/datastructures.html",
      "https://realpython.com/python-dicts/"
    ]
  }
}