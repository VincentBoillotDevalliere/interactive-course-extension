{
  "id": "05-functions",
  "title": "Functions",
  "exercises": [
    {
      "name": "createCalculator",
      "description": "Create a calculator object with add, subtract, multiply, and divide methods",
      "jsTemplate": "function createCalculator() {\n  // TODO: Create and return a calculator object with the following methods:\n  // - add(a, b): returns a + b\n  // - subtract(a, b): returns a - b\n  // - multiply(a, b): returns a * b\n  // - divide(a, b): returns a / b\n  \n}",
      "pyTemplate": "    # TODO: Create and return a calculator object with the following methods:\n    # - add(a, b): returns a + b\n    # - subtract(a, b): returns a - b\n    # - multiply(a, b): returns a * b\n    # - divide(a, b): returns a / b\n    # In Python, return a dictionary with these functions\n    pass",
      "jsTest": "    it(\"should create a calculator with working methods\", () => {\n      const calc = createCalculator();\n      assert.strictEqual(calc.add(1, 2), 3);\n      assert.strictEqual(calc.subtract(5, 2), 3);\n      assert.strictEqual(calc.multiply(2, 3), 6);\n      assert.strictEqual(calc.divide(6, 2), 3);\n    });",
      "pyTest": "    def test_create_calculator(self):\n        calc = createCalculator()\n        self.assertEqual(calc[\"add\"](1, 2), 3)\n        self.assertEqual(calc[\"subtract\"](5, 2), 3)\n        self.assertEqual(calc[\"multiply\"](2, 3), 6)\n        self.assertEqual(calc[\"divide\"](6, 2), 3)"
    },
    {
      "name": "compose",
      "description": "Compose two functions together",
      "jsTemplate": "function compose(f, g) {\n  // TODO: Return a new function that is the composition of f and g\n  // The returned function should take an argument x and return f(g(x))\n  \n}",
      "pyTemplate": "    # TODO: Return a new function that is the composition of f and g\n    # The returned function should take an argument x and return f(g(x))\n    pass",
      "jsTest": "    it(\"should compose functions correctly\", () => {\n      const double = x => x * 2;\n      const increment = x => x + 1;\n      \n      const doubleThenIncrement = compose(increment, double);\n      const incrementThenDouble = compose(double, increment);\n      \n      assert.strictEqual(doubleThenIncrement(3), 7); // double(3) = 6, then increment(6) = 7\n      assert.strictEqual(incrementThenDouble(3), 8); // increment(3) = 4, then double(4) = 8\n    });",
      "pyTest": "    def test_compose(self):\n        def double(x):\n            return x * 2\n        \n        def increment(x):\n            return x + 1\n        \n        double_then_increment = compose(increment, double)\n        increment_then_double = compose(double, increment)\n        \n        self.assertEqual(double_then_increment(3), 7)  # double(3) = 6, then increment(6) = 7\n        self.assertEqual(increment_then_double(3), 8)  # increment(3) = 4, then double(4) = 8"
    },
    {
      "name": "memoize",
      "description": "Create a memoized version of a function",
      "jsTemplate": "function memoize(fn) {\n  // TODO: Return a memoized version of the provided function\n  // The function should cache results for repeated inputs\n  \n}",
      "pyTemplate": "    # TODO: Return a memoized version of the provided function\n    # The function should cache results for repeated inputs\n    pass",
      "jsTest": "    it(\"should memoize function results\", () => {\n      let computeCount = 0;\n      const expensiveComputation = (x) => {\n        computeCount++;\n        return x * 2;\n      };\n      \n      const memoizedFn = memoize(expensiveComputation);\n      \n      assert.strictEqual(memoizedFn(1), 2);\n      assert.strictEqual(computeCount, 1);\n      \n      // This should use the cached result\n      assert.strictEqual(memoizedFn(1), 2);\n      assert.strictEqual(computeCount, 1); // Count should not increase\n      \n      // This should compute a new result\n      assert.strictEqual(memoizedFn(2), 4);\n      assert.strictEqual(computeCount, 2);\n    });",
      "pyTest": "    def test_memoize(self):\n        compute_count = 0\n        \n        def expensive_computation(x):\n            nonlocal compute_count\n            compute_count += 1\n            return x * 2\n        \n        memoized_fn = memoize(expensive_computation)\n        \n        self.assertEqual(memoized_fn(1), 2)\n        self.assertEqual(compute_count, 1)\n        \n        # This should use the cached result\n        self.assertEqual(memoized_fn(1), 2)\n        self.assertEqual(compute_count, 1)  # Count should not increase\n        \n        # This should compute a new result\n        self.assertEqual(memoized_fn(2), 4)\n        self.assertEqual(compute_count, 2)"
    }
  ],
  "resources": {
    "javascript": [
      "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Functions",
      "https://javascript.info/function-basics"
    ],
    "python": [
      "https://docs.python.org/3/tutorial/controlflow.html#defining-functions",
      "https://realpython.com/defining-your-own-python-function/"
    ]
  }
}